package org.openapitools.api;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.Message;
import com.google.protobuf.ProtocolMessageEnum;
import com.googlecode.protobuf.format.JsonFormat;
import org.openbase.bco.registry.remote.Registries;
import org.openbase.bco.registry.template.lib.TemplateRegistry;
import org.openbase.jul.exception.CouldNotPerformException;
import org.openbase.jul.exception.NotAvailableException;
import org.openbase.jul.processing.StringProcessor;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Helper {

    static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
    static final JsonFormat JSON_FORMAT = new JsonFormat();

    static  <T> T invokeMethod(final Object parameter, final Class<T> returnClass) throws CouldNotPerformException {
        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
        String methodName = stackTrace[2].getMethodName();

        // remove the post and get at the end of the method name as generated by the openAPI spec
        // do not remove it in general because the methods themselves can contain these terms
        if (methodName.endsWith("Post")) {
            methodName = methodName.substring(0, methodName.length() - 4);
        } else if (methodName.endsWith("Get")) {
            methodName = methodName.substring(0, methodName.length() - 3);
        }

        methodName = methodName.substring("registry".length());

        int end = 0;
        for (int i = 1; i < methodName.length(); i++) {
            if (Character.isUpperCase(methodName.charAt(i))) {
                end = i;
                break;
            }
        }
        final String registryType = methodName.substring(0, end);
        methodName = methodName.substring(end);

        System.out.println("MethodName: " + methodName);

        Class<?> registryClass = null;
        try {
            registryClass = Registries.class.getMethod("get" + registryType + "Registry", boolean.class).invoke(null, true).getClass();
        } catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new CouldNotPerformException("Could not resolve registry["+registryType+"]", e);
        }
        System.out.println("RegistryClass: " + registryClass.getSimpleName());
        return null;
        //TODO: make independent of registry
        /*Method method = null;
        for (Method m : TemplateRegistry.class.getMethods()) {
            if (m.getName().equals(methodName)) {
                method = m;
            }
        }

        if (method == null) {
            throw new NotAvailableException("method[" + methodName + "]");
        }

        if(method.getParameterTypes().length > 1) {
            //TODO: parse several parameters
            return null;
        } else {
            //TODO parse parameter correctly

            Object result = null;
            try {
                result = method.invoke(Registries.getTemplateRegistry(true), parameter);
                return OBJECT_MAPPER.readValue(JSON_FORMAT.printToString((Message) result), returnClass);
            } catch (IllegalAccessException | IOException | InvocationTargetException | InterruptedException e) {
                throw new CouldNotPerformException("ABC", e);
            }
        }*/
    }

    /*
    static Object convertParameter(final Object actualParameter, final Class expectedParameterClass) throws CouldNotPerformException{
        if (Message.class.isAssignableFrom(expectedParameterClass)) {
            Message.Builder newBuilder = null;
            try {
                newBuilder = (Message.Builder) expectedParameterClass.getMethod("newBuilder").invoke(null);
                JSON_FORMAT.merge(OBJECT_MAPPER.writeValueAsString(actualParameter), newBuilder));
            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | JsonProcessingException e) {


            }

            return newBuilder.build();
        } else if(ProtocolMessageEnum.class.isAssignableFrom(expectedParameterClass)) {
            if(!actualParameter.equals(String.class)) {
                throw new CouldNotPerformException("Unexpected parameter class["+actualParameter.getClass().getSimpleName()+"] for enum. Should be String.class");
            }
            return expectedParameterClass.getMethod("valueOf", String.class).invoke(null, expectedParameterClass);
        }

        return actualParameter;
    }*/
}
